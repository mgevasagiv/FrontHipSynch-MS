%% This script generates stats for main figure 3

clc; clear all;
%% define paths
% addpath('E:\Dropbox\Code\Useful_code')
% addpath(genpath('C:\Users\mgeva\Documents\GitHub\external\eeglab2023.1'))
% addpath(genpath('C:\Users\mgeva\Documents\GitHub\Kamin_iEEG_MAZE_codes'));
% addpath(genpath('C:\Users\mgeva\Documents\GitHub\external\KK_useful\useful'));
% addpath('C:\Users\mgeva\Documents\GitHub\external\fieldtrip-20230613\fieldtrip-20230613\external\brewermap')

% Set path to folders to save results 
maze_set_path;
savedir = [dirs.TF 'pow_hpc_ripple_ofc_n7_grp/'];
fig_savedir = 'E:\MAZE_1.0\analysis\population_manuscript';

osc_source = 'ofc'; %'ofc' or 'GM'
pac_phase_freq = 'alpha';
bootstrapN = 1000; % Cohen's effect size

% Data generated by MAZE11_hpc_mpfc_master.m
mm = matfile(fullfile(savedir, ['5measure_newperm_meta_table_',pac_phase_freq,'.m']));
meta_table = mm.meta_table;

% STATS
% In improved trials - ripples are a significant factor in gamma power / PAC
impv = 1;
data = meta_table;
data = data(data.impv == impv ,:);
model_ml0 = fitlme(data, ['mg ~ event + blk + (epair|subj) '],'DummyVarCoding','effects');
model_ml = fitlme(data, ['mg ~ event + blk  + ripple_occur +  (epair|subj) '],'DummyVarCoding','effects');
table = compare(model_ml0, model_ml)
anova(model_ml)
betaTable = model_ml.Coefficients;


%%
cmap = brewermap(3,'PRGn');
cmap(2,:) = 0.8*cmap(2,:);
for ii = 1:3
    cmap_behav{ii} = cmap(ii,:);
end
% 'X' , 'N', 'G'
cmap_behav{4} = cmap_behav{3}*0.6; % 'preG'


%%
data = meta_table;
data = data(~isnan(data.pac) & ~isnan(data.alpha) & ~isnan(data.mg),:) ;

% Get OFC-MTL epairs
epair = data.epair;
subj = data.subj;

%% STATS - ripple-locked gamma-power 
% Focus on ripple-locked gamma power for learned mazes
data = meta_table;
% Improved trials as we're focusing on effects of experience and event type
% on successful learning
data = data(data.impv == 1 & ~isnan(data.mg),:);
formula_simple = 'mg ~ event + ripple_occur + blk + (1|epair)';
lme_simple = fitlme(data, formula_simple);
anova(lme_simple)
betaTable = lme_simple.Coefficients;

% Adding interactions for a complete picture
formula = 'mg ~ event + ripple_occur + blk + event * ripple_occur + blk * ripple_occur + (1|epair)';
lme1 = fitlme(data,formula);
anova(lme1)
betaTable = lme1.Coefficients;

% Focus on ripple-locked gamma power for learnt mazes
data = meta_table;
data = data(data.blk == 1 & data.ripple_occur==1 ,:);
formula = 'impv ~ mg * event  + (1|subj)';
lme1 = fitlme(data,formula);
anova(lme1)

% Another approach - compare whether the interaction explains more than
% each factor seperately
data1 = data(data.blk == 1 & data.ripple_occur== 1,:);
formula = 'impv ~  mg +  event  + (mg|epair)';
lme1 = fitlme(data1,formula);
formula = 'impv ~ mg * event + (mg|epair) ';
lme2 = fitlme(data1,formula);
results = compare(lme1,lme2);
disp(results.pValue)
% P = 0.002


data = meta_table;
data = data(~isnan(data.pac) & ~isnan(data.alpha) & ~isnan(data.mg),:) ;
formula = 'mg ~ event * blk + (epair|subj)';
lme1 = fitlme(data,formula);
formula = 'mg ~ ripple_occur * event * blk  + (epair|subj)';
lme2 = fitlme(data,formula);
results = compare(lme1,lme2);
disp(results.pValue)
betaTable = lme2.Coefficients;


%% Figure - S4D - Ripple-locked OFC gamma power per event-type
newA4figure('cohens_effectSize_blk')
fig_name = 'cohens_effectSize_blk';

EvTypePlot =  {'X','preG','G','N'};
clear p_rs 
for ii = 1:length(EvTypePlot)

    data = meta_table;
    data = data(data.ripple_occur == 1 & ~isnan(data.mg),:) ;
    
    data_x = data.mg( data.impv == 1 & data.blk == 1 & data.ripple_occur == 1 & ... 
                            strcmp(data.event,EvTypePlot{ii}) );

    data_y = data.mg( data.impv == 1 & data.blk == 2 & data.ripple_occur == 1 & ... 
                            strcmp(data.event,EvTypePlot{ii}) );

    [p_rs(ii) ,h] = ranksum(data_x,data_y);
    effect = meanEffectSize(data_x,data_y,Effect ="cohen",ConfidenceIntervalType="bootstrap", ...
                     BootstrapOptions=statset(UseParallel=true),NumBootstraps=1000);
    subplot(2,2,ii)
    h = gardnerAltmanPlot(data_x,data_y,Paired=false,Effect="robustcohen",Alpha=0.05);
    stringT = sprintf('%s, P = %2.2d, Robust Cohens d = %2.2d',EvTypePlot{ii},p_rs(ii), effect.Effect)
    title(stringT)
    ylabel('OFC ripple-locked Gamma power');
    ax = get(gca);
    set(gca,'xticklabel',{'Blk 1','Blk 2', 'Robust Cohen''s d'},'ylim',[0 20], 'YTick',[0 20])

   
    % data_i = data( data.impv == 1 & data.ripple_occur == 1 & strcmp(data.event,EvTypePlot{ii}),:) ;
    % interactionplot(data_i.mg,[data_i.blk, data_i.OFC_axis],'varnames',{'B','O'})

end
saveas(gcf, fullfile(savedir,fig_name),'tiff')
close(gcf)


%% diferences between inpv/degraded paths
newA4figure('')
fig_name = sprintf('mg_event_rippleLocked_impvDeg_blocks1');

EvTypePlot =  {'X','preG','N','G','E'};
FaceColor = [cmap_behav{1}; cmap_behav{4}; cmap_behav{2}; cmap_behav{3}; cmap_behav{2}];  
x_w = 0.1;
y_w = 0.15;
positions(1,:) = [0.1 0.1 x_w y_w];
positions(2,:) = [0.22 0.1 x_w y_w];
positions(3,:) = [0.34 0.1 x_w y_w];
positions(4,:) = [0.48 0.1 x_w y_w];
positions(5,:) = [0.62 0.1 x_w y_w];
clear A A_se p

% data = data(data.OFC_axis == 0,:);
for ii = 1:length(EvTypePlot)
    axes('position',positions(ii,:))
    hold all
    title(EvTypePlot{ii})
    clear A B
    jj = 1;
    vec = data.mg(data.blk == 1 & data.impv == 1 & data.ripple_occur==1 & ~isnan(data.mg) & strcmp(data.event,EvTypePlot{ii}));
    vec1 = vec;
    A(jj) = nanmean(vec);
    A_se(jj) = nanstd(vec)/sqrt(length(vec));
    vec = data.mg(data.blk == 1  & data.impv == 0  & data.ripple_occur==1 & ~isnan(data.mg) & strcmp(data.event,EvTypePlot{ii}));
    vec2 = vec;
    
    jj = jj + 1;
    A(jj) = nanmean(vec);
    A_se(jj) = nanstd(vec)/sqrt(length(vec));
    %     vec = data.pac(data.ripple_occur==0 & ~isnan(data.pac) & strcmp(data.event,EvType{ii}) & data.blk == 2 ,:);
    %     jj = 1;
    %     B(jj) = nanmean(vec);
    %     B_se(jj) = nanstd(vec)/sqrt(length(vec));
    %     vec = data.pac(data.ripple_occur==1 & ~isnan(data.pac) & strcmp(data.event,EvType{ii}) & data.blk == 2 ,:);
    %     jj = jj + 1;
    %     B(jj) = nanmean(vec);
    %     B_se(jj) = nanstd(vec)/sqrt(length(vec));
    
    bb = bar(A);
    bb.FaceColor = FaceColor(ii,:);
    set(gca,'xtick',[1 2],'XTickLabel',{'Impv','Degraded'},'XTickLabelRotation',30 ,'ylim',[0 10],'YTick',[0 5 10])
    errorbar(1:2,A,A_se,'k.')
    % errorbar([2-0.15,2+.15],B,B_se,'k.')
    try
    [p(ii),h] = ranksum(vec1,vec2);
    if p(ii) < 0.05
        plot(1.5,8,'k*','markersize',7)
    end
    if ii == 1;
        ylabel('Gamma power <% change>')
    end
    catch
        warning('not enough entries for ranksum')
    end
end
% saveas(gcf, fullfile(savedir,fig_name),'tiff')
% close(gcf)

%% Changes over blocks
%%
fig_name = sprintf('mg_event_rippleLocked_impv_blocks12');

data = meta_table;
data = data(~isnan(data.pac) & ~isnan(data.alpha) & ~isnan(data.mg),:) ;

impv = 1;
data = data(data.impv == impv ,:);

newA4figure('')
EvTypePlot =  {'X','preG','N','G','E'};
x_w = 0.1;
y_w = 0.15;
positions(1,:) = [0.1 0.1 x_w y_w];
positions(2,:) = [0.22 0.1 x_w y_w];
positions(3,:) = [0.34 0.1 x_w y_w];
positions(4,:) = [0.48 0.1 x_w y_w];
positions(5,:) = [0.62 0.1 x_w y_w];
clear A A_se p
for ii = 1:length(EvTypePlot)
    axes('position',positions(ii,:))
    hold all
    title(EvTypePlot{ii})
    clear A B
    jj = 1;
    vec = data.mg(data.impv == 1 & data.blk ==1 & data.ripple_occur==1 & strcmp(data.event,EvTypePlot{ii}));
    vec1 = vec;
    A(jj) = nanmean(vec);
    A_se(jj) = nanstd(vec)/sqrt(length(vec));
    vec = data.mg(data.impv == 1 & data.blk ==2   & data.ripple_occur==1 & strcmp(data.event,EvTypePlot{ii}));
    vec2 = vec;
    
    jj = jj + 1;
    A(jj) = nanmean(vec);
    A_se(jj) = nanstd(vec)/sqrt(length(vec));

    bb = bar(A);
    bb.FaceColor = FaceColor(ii,:);
    set(gca,'xtick',[1 2],'XTickLabel',{'blk 1','blk 2'},'XTickLabelRotation',30 ,'ylim',[0 10],'ytick',[0 5 10])
    errorbar(1:2,A,A_se,'k.')
    % errorbar([2-0.15,2+.15],B,B_se,'k.')
    
    try
    [p(ii),h] = ranksum(vec1,vec2);
    if p(ii) < 0.05
        plot(1.5,8,'k*','markersize',10)
    end
    if ii == 1;
        ylabel('Gamma power <% change>')
    end
    catch
        warning('not enough data for ranksum')
    end
end
%saveas(gcf, fullfile(savedir,fig_name),'tiff')
% close(gcf)

%% Main Fig. 3, Panel C
% Demonstrating this synchronization is higher on high-load events
EvTypePlot =  {'X','N','preG','G','E'};
cmap = brewermap(3,'PRGn');
cmap_1d = brewermap(6,'Oranges');
clear A B
for ii = 1:length(EvTypePlot)
    for jj = 1:2
        vec = data.mg(data.impv == 1 & data.blk == jj & data.ripple_occur==1 & strcmp(data.event,EvTypePlot{ii}));
        A(ii,jj) = nanmean(vec);
    end
end
newA4figure('colorCode_block1_impv')
IM = imagesc(A(:,1),[0 7])
colorbar
set(gca,'ytick',1:5,'YTickLabel',EvTypePlot,'XTick',1:2)
xlabel('block 1')
saveas(gcf, fullfile(savedir,get(gcf,'name')),'tiff')

newA4figure('colorCode_block2_impv')
IM = imagesc(A(:,2),[0 7])
colorbar
set(gca,'ytick',1:5,'YTickLabel',EvTypePlot,'XTick',1,'XTickLabel','2')
xlabel('block 2')
saveas(gcf, fullfile(savedir,get(gcf,'name')),'tiff')

%% Main Fig. 3, Panel D 
% Demonstrating that though synchronization is higher on high-load events, but not on trials that do not lead to learning 
data = meta_table;
data = data(~isnan(data.pac) & ~isnan(data.alpha) & ~isnan(data.mg),:) ;

EvTypePlot =  {'X','N','preG','G','E'};
cmap = brewermap(3,'PRGn');
cmap_1d = brewermap(6,'Oranges');
clear A B
for ii = 1:length(EvTypePlot)
    for jj = 1:2
        vec = data.mg(data.impv == jj-1 & data.blk == 1 & data.ripple_occur==1 & strcmp(data.event,EvTypePlot{ii}));
        A(ii,jj) = nanmean(vec);
    end
end
newA4figure('colorCode_block1_impv_v2')
IM = imagesc(A(:,2),[0 7])
colorbar
set(gca,'ytick',1:5,'YTickLabel',EvTypePlot,'XTick',1:2)
xlabel('Impv')
saveas(gcf, fullfile(savedir,get(gcf,'name')),'tiff')

newA4figure('colorCode_block1_degrade')
IM = imagesc(A(:,1),[0 7])
colorbar
set(gca,'ytick',1:5,'YTickLabel',EvTypePlot,'XTick',1,'XTickLabel','2')
xlabel('degraded')
saveas(gcf, fullfile(savedir,get(gcf,'name')),'tiff')



%% Gamma power is associated with locations in the maze Retrieval processes

Data_b2_impv = data(~isnan(data.mg) & ~isnan(data.alpha) & data.blk == 2 & data.impv == 1,:);
formula = 'mg ~ event + (epair|subj)';
lme1 = fitlme(Data_b2_impv,formula);
[p tbl stats] = anovan(Data_b2_impv.mg(:), {Data_b2_impv.event});
figure; multcompare(stats)

dataForDisplay = data(ismember(data.event,{'X','O','N','preG'}),:);
newA4figure('')
axes('position',[0.1 0.1 0.2 0.12])
distributionPlot(dataForDisplay.mg,'groups',dataForDisplay.event,'xValues',[1 3 2 4],'histOpt',0,'showMM',2)
axis([0 5 0 15])

fig_name = 'OFC_PAC_events';
saveas(gcf, fullfile(savedir,fig_name),'tiff')


